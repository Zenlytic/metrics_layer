"""Tests for SeedMetricsLayer.seed_single_view()."""

import pandas as pd
import pytest

from metrics_layer.cli.seeding import SeedMetricsLayer
from metrics_layer.core.model.definitions import Definitions


def _make_seeder(connection, query_type, monkeypatch, run_query_mock, **kwargs):
    """Build a SeedMetricsLayer with mocked query execution."""
    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = query_type

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        kwargs.get("database", "analytics"),
        kwargs.get("schema", "analytics"),
        kwargs.get("table", "orders"),
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    # Restore after the test via finalizer (caller should use yield or addfinalizerr)
    # For simplicity we just return old_type so the test can restore it
    return seeder, old_type


@pytest.mark.seeding
@pytest.mark.parametrize(
    "query_type,fixture_name",
    [
        (Definitions.snowflake, "seed_snowflake_tables_data"),
        (Definitions.postgres, "seed_postgres_tables_data"),
        (Definitions.bigquery, "seed_bigquery_tables_data"),
        (Definitions.databricks, "seed_databricks_tables_data"),
        (Definitions.redshift, "seed_redshift_tables_data"),
        (Definitions.mysql, "seed_mysql_tables_data"),
    ],
)
def test_seed_single_view_returns_view_dict(
    connection,
    monkeypatch,
    query_type,
    fixture_name,
    request,
    seed_snowflake_tables_data,
    seed_postgres_tables_data,
    seed_bigquery_tables_data,
    seed_databricks_tables_data,
    seed_redshift_tables_data,
    seed_mysql_tables_data,
):
    """seed_single_view returns a well-formed view dict with correct fields."""
    fixture_lookup = {
        "seed_snowflake_tables_data": seed_snowflake_tables_data,
        "seed_postgres_tables_data": seed_postgres_tables_data,
        "seed_bigquery_tables_data": seed_bigquery_tables_data,
        "seed_databricks_tables_data": seed_databricks_tables_data,
        "seed_redshift_tables_data": seed_redshift_tables_data,
        "seed_mysql_tables_data": seed_mysql_tables_data,
    }
    table_data = fixture_lookup[fixture_name]

    table_comments = pd.DataFrame()
    if query_type in {Definitions.snowflake, Definitions.databricks}:
        if query_type == Definitions.snowflake:
            table_comments = pd.DataFrame(
                [{"TABLE_SCHEMA": "ANALYTICS", "TABLE_NAME": "ORDERS", "COMMENT": "orders table, bro"}]
            )
        else:
            table_comments = pd.DataFrame(
                [{"TABLE_SCHEMA": "analytics", "TABLE_NAME": "orders", "COMMENT": "orders table, bro"}]
            )

    call_count = {"n": 0}

    def run_query_mock(query):
        call_count["n"] += 1
        if ".COLUMNS" in query.upper() or "COLUMN_FIELD_PATHS" in query.upper():
            return table_data
        if ".TABLES" in query.upper():
            return table_comments
        return pd.DataFrame()

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = query_type

    schema = "analytics" if query_type != Definitions.druid else "druid"
    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        schema,
        "orders",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view = seeder.seed_single_view(model_name="test_model")
    finally:
        connection._raw_connections[0].type = old_type

    # Basic structure
    assert view is not None
    assert view["type"] == "view"
    assert view["name"] == "orders"
    assert view["model_name"] == "test_model"
    assert "sql_table_name" in view
    assert "fields" in view
    assert len(view["fields"]) == 14

    # Verify field types
    order_id = next(f for f in view["fields"] if f["name"] == "order_id")
    assert order_id["field_type"] == "dimension"

    date_field = next(f for f in view["fields"] if f["name"] == "order_created_at")
    assert date_field["field_type"] == "dimension_group"
    assert date_field["type"] == "time"
    assert "timeframes" in date_field

    # Table comment should be set for Snowflake/Databricks
    if query_type in {Definitions.snowflake, Definitions.databricks}:
        assert view.get("description") == "orders table, bro"

    # No measures should be generated by seeding
    assert all(f["field_type"] != "measure" for f in view["fields"])


@pytest.mark.seeding
def test_seed_single_view_snowflake_sql_table_name(
    connection,
    seed_snowflake_tables_data,
):
    """Snowflake views should have quoted schema.table sql_table_name."""

    def run_query_mock(query):
        if ".COLUMNS" in query.upper():
            return seed_snowflake_tables_data
        if ".TABLES" in query.upper():
            return pd.DataFrame([{"TABLE_SCHEMA": "ANALYTICS", "TABLE_NAME": "ORDERS", "COMMENT": None}])
        return pd.DataFrame()

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = Definitions.snowflake

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        "orders",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view = seeder.seed_single_view(model_name="base_model")
    finally:
        connection._raw_connections[0].type = old_type

    assert view["sql_table_name"] == '"ANALYTICS"."ORDERS"'


@pytest.mark.seeding
def test_seed_single_view_default_date(
    connection,
    seed_snowflake_tables_data,
):
    """When tag_default_date=True, the first dimension_group should be set as default_date."""

    def run_query_mock(query):
        if ".COLUMNS" in query.upper():
            return seed_snowflake_tables_data
        if ".TABLES" in query.upper():
            return pd.DataFrame([{"TABLE_SCHEMA": "ANALYTICS", "TABLE_NAME": "ORDERS", "COMMENT": None}])
        return pd.DataFrame()

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = Definitions.snowflake

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        "orders",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view_with_date = seeder.seed_single_view(model_name="base_model", tag_default_date=True)
        view_without_date = seeder.seed_single_view(model_name="base_model", tag_default_date=False)
    finally:
        connection._raw_connections[0].type = old_type

    assert "default_date" in view_with_date
    assert view_with_date["default_date"] == "order_created_at"
    assert "default_date" not in view_without_date


@pytest.mark.seeding
def test_seed_single_view_returns_none_for_nonexistent_table(connection):
    """Returns None when the warehouse query returns no rows for the table."""

    def run_query_mock(query):
        columns = ["TABLE_CATALOG", "TABLE_SCHEMA", "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE"]
        return pd.DataFrame(columns=columns)

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = Definitions.snowflake

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        "nonexistent_table",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view = seeder.seed_single_view(model_name="base_model")
    finally:
        connection._raw_connections[0].type = old_type

    assert view is None


@pytest.mark.seeding
def test_seed_single_view_returns_none_for_empty_dataframe(connection):
    """Returns None when the warehouse returns a completely empty DataFrame."""

    def run_query_mock(query):
        return pd.DataFrame()

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = Definitions.snowflake

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        "some_table",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view = seeder.seed_single_view(model_name="base_model")
    finally:
        connection._raw_connections[0].type = old_type

    assert view is None


@pytest.mark.seeding
def test_seed_single_view_raises_without_table_name(connection):
    """Raises ValueError when the seeder was constructed without a table name."""
    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        None,  # no table name
        metrics_layer=connection,
        run_query_override=lambda q: pd.DataFrame(),
    )

    with pytest.raises(ValueError, match="requires a specific table name"):
        seeder.seed_single_view(model_name="base_model")


@pytest.mark.seeding
def test_seed_single_view_uses_provided_model_name(
    connection,
    seed_snowflake_tables_data,
):
    """The model_name parameter should appear in the returned view dict."""

    def run_query_mock(query):
        if ".COLUMNS" in query.upper():
            return seed_snowflake_tables_data
        if ".TABLES" in query.upper():
            return pd.DataFrame([{"TABLE_SCHEMA": "ANALYTICS", "TABLE_NAME": "ORDERS", "COMMENT": None}])
        return pd.DataFrame()

    old_type = connection._raw_connections[0].type
    connection._raw_connections[0].type = Definitions.snowflake

    seeder = SeedMetricsLayer(
        "testing_snowflake",
        "analytics",
        "analytics",
        "orders",
        metrics_layer=connection,
        run_query_override=run_query_mock,
    )

    try:
        view = seeder.seed_single_view(model_name="my_custom_model")
    finally:
        connection._raw_connections[0].type = old_type

    assert view["model_name"] == "my_custom_model"
